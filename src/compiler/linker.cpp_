/*🐟Eel🐟*/
#include "linker.h"

namespace Eel {

	void Linker::proceed(Block& block) {
		auto& result = _analyzer.proceed(block._env);

		for (auto& command : result.commands) {
			proceedCommand(block, command);
		}
	}

	void Linker::proceedCommand(Block& block, const Analyzer::Command& aCommand) {
		auto& bCommand = block._commands.emplace_back();

		std::vector<Type> argTypes;
		argTypes.reserve(aCommand.args.size());
		for (const auto& arg : aCommand.args) {
			argTypes.emplace_back(arg.valueType);
		}

		bCommand._func = &block._globalProviders.emplace_back(block._env, aCommand.name, argTypes);
		convertVariable(&bCommand._result, block, aCommand.result);

		for (auto& arg : aCommand.args) {
			convertVariable(&bCommand._args.emplace_back(), block, arg);
		}
	}

	void Linker::convertVariable(ValueProvider** provider, Block& block, const Analyzer::Variable& variable) {
		switch (variable.type) {
		case Analyzer::Variable::Type::Global: {
			*provider = &block._globalProviders.emplace_back(block._env, variable.id);
			break;
		}
		case Analyzer::Variable::Type::Stack: {
			*provider = &block._stackProviders.try_emplace(variable.stack, block.holder, variable.stack).first->second;
			break;
		}
		case Analyzer::Variable::Type::Literal: {
			switch (variable.literal.number.type) {
			case UniValue::Number::Type::Int32: {
				*provider = &block._literalProviders.emplace_back(variable.literal.number.vInt32);
				break;
			}
			case UniValue::Number::Type::Int64: {
				*provider = &block._literalProviders.emplace_back(variable.literal.number.vInt64);
				break;
			}
			case UniValue::Number::Type::Float32: {
				*provider = &block._literalProviders.emplace_back(variable.literal.number.vFloat32);
				break;
			}
			case UniValue::Number::Type::Float64: {
				*provider = &block._literalProviders.emplace_back(variable.literal.number.vFloat64);
				break;
			}
			}
			break;
		}
		}
	}

}