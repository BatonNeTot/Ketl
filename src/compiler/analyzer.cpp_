/*🐟Eel🐟*/
#include "analyzer.h"

#include "eel.h"

#include <unordered_set>
#include <unordered_map>
#include <sstream>

namespace Eel {

	const Analyzer::Result& Analyzer::proceed(Environment& env) {
		if (_result != nullptr) {
			return *_result;
		}

		_result = new Result();

		AnalyzerInfo info;

		while (_parser.hasNext()) {
			auto& node = _parser.getNext();
			proceedCommands(env, _result->commands, info, node);
		}

		return *_result;
	}

	Analyzer::Variable Analyzer::proceedCommands(Environment& env, std::list<Analyzer::Command>& list, Analyzer::AnalyzerInfo& info, const Parser::Node& node) {
		switch (node.type) {
		case Parser::Node::Type::Operator: {
			if (node.value.str == "()") {
				return proceedCommands(env, list, info, *node.args[0]);
			}

			std::vector<Variable> args;
			args.reserve(node.args.size());
			for (auto& arg : node.args) {
				auto var = proceedCommands(env, list, info, *arg);
				args.emplace_back(var);
			}

			if (node.value.str == "=" && args[0].valueType == Type::Void) {
				args[0].valueType = args[1].valueType;
				env.registerGlobal(args[0].id, args[0].valueType);
			}

			if (node.value.str == "=") {
				auto resultType = env.getGlobalType(args[0].id);

				if (resultType != args[1].valueType) {

				}

				auto& lastCommand = list.back();
				lastCommand.result = args[0];

				return lastCommand.result;
			}

			std::vector<Type> argTypes;
			argTypes.reserve(args.size());
			for (auto& arg : args) {
				argTypes.emplace_back(arg.valueType);
			}

			auto func = env.estimateFunctionByDecl("operator " + node.value.str, argTypes);

			for (auto i = 0u; i < argTypes.size(); ++i) {
				if (args[i].valueType != func.args[i]) {
					auto stack = info.getFreeStack();
					auto& command = list.emplace_back();
					command.name = func.args[i].castTargetStr();

					command.result.type = Variable::Type::Stack;
					command.result.stack = stack;
					command.result.valueType = func.args[i];

					command.args.emplace_back(args[i]);
					args[i] = command.result;
				}
			}

			auto& command = list.emplace_back();
			command.name = "operator " + node.value.str;

			command.result.type = Variable::Type::Stack;
			command.result.stack = info.getFreeStack();
			command.result.valueType = *func.result;

			command.args = args;

			return command.result;
		}
		case Parser::Node::Type::Number: {
			Variable variable;
			variable.type = Variable::Type::Literal;
			variable.literal = node.value;
			variable.valueType = node.value.asType();
			return variable;
		}
		case Parser::Node::Type::Id: {
			Variable variable;
			variable.type = Variable::Type::Global;
			variable.id = node.value.str;
			variable.valueType = env.getGlobalType(variable.id);
			return variable;
		}
		}

		return {};
	}

}